{"remainingRequest":"/app/node_modules/vue-loader/lib/index.js??vue-loader-options!/app/src/components/content/ShelfDisplayPuzzle.vue?vue&type=style&index=0&id=57e4b1c8&lang=scss&scoped=true&","dependencies":[{"path":"/app/src/components/content/ShelfDisplayPuzzle.vue","mtime":1683275992553},{"path":"/app/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/app/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/app/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/app/node_modules/sass-loader/dist/cjs.js","mtime":499162500000},{"path":"/app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/app/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKLnB1enpsZSB7CiAgJi1waWVjZSB7CgogICAgJi53aXRoLW91dGxpbmUgewogICAgICBvdXRsaW5lOiAycHggc29saWQgIzAwOTlGRjsKICAgIH0KCiAgICAmLWluZGljYXRvciB7CiAgICAgIEBhcHBseSBvcGFjaXR5LTA7CgogICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgZWFzZTsKICAgIH0KCiAgICAmLmRyYWdnYWJsZS1zb3VyY2UtLWlzLWRyYWdnaW5nICYtaW5kaWNhdG9yIHsKICAgICAgQGFwcGx5IG9wYWNpdHktNzU7CiAgICB9CiAgfQoKICAmLXdpbi1vdmVybGF5IHsKICAgIEBhcHBseSBhYnNvbHV0ZTsKICAgIEBhcHBseSBsZWZ0LTA7CiAgICBAYXBwbHkgdG9wLTA7CiAgICBAYXBwbHkgdy1mdWxsOwogICAgQGFwcGx5IGgtZnVsbDsKICAgIEBhcHBseSBiZy1ibHVlLTUwMDsKICAgIEBhcHBseSB6LTEwOwogICAgQGFwcGx5IG9wYWNpdHktNTA7CgogICAgYW5pbWF0aW9uLW5hbWU6IGZsYXNoOwogICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAxczsKICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2U7CiAgfQoKICAmLXJlc3RhcnQtYnV0dG9uIHsKICAgIEBhcHBseSBwLTA7CiAgICBAYXBwbHkgdGV4dC1ncmF5LTkwMDsKICAgIEBhcHBseSB1bmRlcmxpbmU7CiAgICBAYXBwbHkgdGV4dC0zeGw7CiAgICBAYXBwbHkgZm9udC1ub3JtYWw7CiAgfQoKICAvZGVlcC8gLmRyYWdnYWJsZS1taXJyb3IgewogICAgQGFwcGx5IG9wYWNpdHktNzU7CiAgfQp9CgpAa2V5ZnJhbWVzIGZsYXNoIHsKICAwJSwKICAyNSUsCiAgNzUlIHsKICAgIEBhcHBseSBvcGFjaXR5LTA7CiAgfQoKICA1MCUsCiAgMTAwJSB7CiAgICBAYXBwbHkgb3BhY2l0eS01MDsKICB9Cn0KCg=="},{"version":3,"sources":["ShelfDisplayPuzzle.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoUA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"ShelfDisplayPuzzle.vue","sourceRoot":"src/components/content","sourcesContent":["<template>\n  <div class=\"puzzle container\">\n    <div ref=\"puzzleContainer\">\n      <h3\n        class=\"text-center\"\n        v-html=\"$options.filters.formatContent(shelf_display_puzzle.headline)\"\n      />\n\n      <h6\n        class=\"mt-4 text-center\"\n        v-html=\"$options.filters.formatContent(shelf_display_puzzle.subheadline)\"\n      />\n\n      <div\n        v-observe-visibility=\"visibilityChanged\"\n        class=\"puzzle-pieces-container mt-16 flex flex-wrap relative focus:outline-none\"\n        :style=\"{\n          width: `${puzzleWidth}px`,\n          height: `${puzzleHeight}px`,\n        }\"\n      >\n        <div\n          v-for=\"piece in sortedPuzzle\"\n          :key=\"`${componentKey}${piece.id}`\"\n          class=\"puzzle-piece relative\"\n          :class=\"{ 'with-outline' : !isFinished}\"\n          :data-id=\"piece.id\"\n          :style=\"{\n            width: `${getPieceDimensions().width}px`,\n            height: `${getPieceDimensions().height}px`,\n            backgroundImage: `url(${image})`,\n            backgroundRepeat: 'no-repeat',\n            backgroundSize: `${puzzleWidth}px ${puzzleHeight}px`,\n            backgroundPosition: `${getPieceXOffset(piece)} ${getPieceYOffset(piece)}`,\n          }\"\n        >\n          <div\n            class=\"puzzle-piece-indicator w-full h-full opacity-50 bg-blue-400\"\n          />\n        </div>\n      </div>\n    </div>\n\n    <div\n      v-if=\"isFinished\"\n      class=\"mt-4\"\n    >\n      <h2\n        v-if=\"hasSuccessMessage\"\n        class=\"mb-4 px-8 text-center\"\n        v-html=\"$options.filters.formatContent(successMessage)\"\n      />\n\n      <div class=\"flex justify-center\">\n        <apo-button\n          class=\"puzzle-restart-button button button--tiny button--outlined\"\n          type=\"button\"\n          @click=\"restart\"\n          v-text=\"$t('modules.shelfDisplay.restart')\"\n        />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\n\nimport clone from 'lodash/clone';\nimport get from 'lodash/get';\nimport sortBy from 'lodash/sortBy';\nimport { Swappable } from '@shopify/draggable/lib/es5/draggable.bundle.legacy';\n\nexport default {\n  props: {\n    shelf_display_puzzle: {\n      type: Object,\n      required: true,\n    },\n  },\n\n  data() {\n    return {\n      image: '',\n      originalImageWidth: 0,\n      originalImageHeight: 0,\n      puzzle: [],\n      puzzleWidth: 0,\n      currentSwap: {\n        sourceId: null,\n        targetId: null,\n      },\n      isFinished: false,\n      // This property is used in conjunction as the key for each puzzle piece item\n      // and is being counted up every time the DOM has been manipulated by the Swappable\n      // library. This causes vue to re-render all the list items to reflect the current\n      // data state correctly.\n      componentKey: 0,\n    };\n  },\n\n  computed: {\n    rows() {\n      const rows = get(this.shelf_display_puzzle, 'size.rows') || 4;\n\n      return parseInt(rows, 10);\n    },\n\n    columns() {\n      const columns = get(this.shelf_display_puzzle, 'size.columns') || 4;\n\n      return parseInt(columns, 10);\n    },\n\n    columnWidth() {\n      return 100 / this.columns;\n    },\n\n    columnHeight() {\n      return 100 / this.rows;\n    },\n\n    puzzleHeight() {\n      const heightRatio = this.puzzleWidth / this.originalImageWidth;\n\n      return this.originalImageHeight * heightRatio;\n    },\n\n    sortedPuzzle() {\n      return sortBy(this.puzzle, 'index');\n    },\n\n    hasSuccessMessage() {\n      return this.successMessage && this.successMessage.length > 0;\n    },\n\n    successMessage() {\n      return this.shelf_display_puzzle.success_message;\n    },\n  },\n\n  watch: {\n    shelf_display_puzzle: {\n      immediate: true,\n      deep: true,\n      handler(shelfDisplayPuzzle) {\n        const image = get(shelfDisplayPuzzle, 'image.sizes.post-thumbnail');\n\n        if (image && image.length > 0) {\n          this.image = image;\n        }\n      },\n    },\n\n    image: {\n      immediate: true,\n      handler(image) {\n        if (!image || image.length === 0) {\n          return;\n        }\n\n        this.imageInstance = new Image();\n\n        this.imageInstance.onload = () => {\n          this.generatePuzzle();\n        };\n\n        this.imageInstance.src = image;\n      },\n    },\n  },\n\n  methods: {\n    generatePuzzle() {\n      this.storeOriginalImageDimensions();\n      this.createPuzzlePieces();\n      this.shufflePuzzlePieces();\n\n      this.$nextTick(() => {\n        this.createSwappableInstance();\n      });\n    },\n\n    createPuzzlePieces() {\n      let index = 0;\n      const puzzle = [];\n\n      for (let row = 0; row < this.rows; row += 1) {\n        for (let column = 0; column < this.columns; column += 1) {\n          puzzle.push({\n            id: `${row}-${column}`,\n            row,\n            column,\n            originalIndex: index,\n            index,\n          });\n\n          index += 1;\n        }\n      }\n\n      this.puzzle = puzzle;\n    },\n\n    shufflePuzzlePieces() {\n      const availableIndices = [...Array(this.columns * this.rows).keys()];\n\n      this.puzzle = this.puzzle.map(piece => {\n        const index = availableIndices\n          .splice(Math.floor(Math.random() * availableIndices.length), 1);\n\n        /* eslint-disable prefer-destructuring, no-param-reassign */\n        piece.index = index[0];\n        /* eslint-enable */\n\n        return piece;\n      });\n    },\n\n    createSwappableInstance() {\n      const container = this.$refs.puzzleContainer.querySelector('.puzzle-pieces-container');\n\n      this.swappable = new Swappable(container, {\n        draggable: '.puzzle-piece',\n      });\n\n      this.swappable.on('swappable:swapped', payload => {\n        this.currentSwap.sourceId = payload.data.dragEvent.data.source.dataset.id;\n        this.currentSwap.targetId = payload.data.swappedElement.dataset.id;\n      });\n      this.swappable.on('swappable:stop', () => {\n        if (this.isCurrentSwapValid()) {\n          const sourcePiece = this.puzzle.find(piece => piece.id === this.currentSwap.sourceId);\n          const targetPiece = this.puzzle.find(piece => piece.id === this.currentSwap.targetId);\n\n          const sourceIndex = clone(sourcePiece.index);\n\n          sourcePiece.index = clone(targetPiece.index);\n          targetPiece.index = sourceIndex;\n\n          this.$nextTick(() => {\n            this.componentKey += 1;\n\n            this.checkWinConditions();\n          });\n        }\n\n        this.resetCurrentSwap();\n      });\n    },\n\n    checkWinConditions() {\n      this.isFinished = this.puzzle.every(piece => piece.index === piece.originalIndex);\n    },\n\n    determinePuzzleWidth() {\n      this.puzzleWidth = this.$refs.puzzleContainer.getBoundingClientRect().width;\n    },\n\n    storeOriginalImageDimensions() {\n      this.originalImageWidth = this.imageInstance.width;\n      this.originalImageHeight = this.imageInstance.height;\n    },\n\n    getPieceDimensions() {\n      return {\n        width: this.puzzleWidth / this.columns,\n        height: this.puzzleHeight / this.rows,\n      };\n    },\n\n    getPieceXOffset(piece) {\n      const pieceWidth = this.getPieceDimensions().width;\n      const pieceOffset = pieceWidth * piece.column * -1;\n\n      return `${pieceOffset}px`;\n    },\n\n    getPieceYOffset(piece) {\n      const pieceHeight = this.getPieceDimensions().height;\n      const pieceOffset = pieceHeight * piece.row * -1;\n\n      return `${pieceOffset}px`;\n    },\n\n    isCurrentSwapValid() {\n      return this.currentSwap.sourceId !== null && this.currentSwap.targetId !== null;\n    },\n\n    resetCurrentSwap() {\n      this.currentSwap.sourceId = null;\n      this.currentSwap.targetId = null;\n    },\n\n    restart() {\n      this.isFinished = false;\n      this.shufflePuzzlePieces();\n    },\n\n    visibilityChanged(isVisible) {\n      if (isVisible) {\n        this.determinePuzzleWidth();\n      }\n    },\n  },\n\n  mounted() {\n    this.determinePuzzleWidth();\n\n    const onResizeListener = () => {\n      this.determinePuzzleWidth();\n    };\n\n    window.addEventListener('resize', onResizeListener);\n\n    this.$once('hook:destroyed', () => {\n      window.removeEventListener('resize', onResizeListener);\n    });\n  },\n};\n\n</script>\n\n<style lang=\"scss\" scoped>\n\n.puzzle {\n  &-piece {\n\n    &.with-outline {\n      outline: 2px solid #0099FF;\n    }\n\n    &-indicator {\n      @apply opacity-0;\n\n      transition: opacity 0.1s ease;\n    }\n\n    &.draggable-source--is-dragging &-indicator {\n      @apply opacity-75;\n    }\n  }\n\n  &-win-overlay {\n    @apply absolute;\n    @apply left-0;\n    @apply top-0;\n    @apply w-full;\n    @apply h-full;\n    @apply bg-blue-500;\n    @apply z-10;\n    @apply opacity-50;\n\n    animation-name: flash;\n    animation-duration: 1s;\n    animation-timing-function: ease;\n  }\n\n  &-restart-button {\n    @apply p-0;\n    @apply text-gray-900;\n    @apply underline;\n    @apply text-3xl;\n    @apply font-normal;\n  }\n\n  /deep/ .draggable-mirror {\n    @apply opacity-75;\n  }\n}\n\n@keyframes flash {\n  0%,\n  25%,\n  75% {\n    @apply opacity-0;\n  }\n\n  50%,\n  100% {\n    @apply opacity-50;\n  }\n}\n\n</style>\n"]}]}