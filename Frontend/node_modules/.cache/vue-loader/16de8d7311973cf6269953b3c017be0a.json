{"remainingRequest":"/app/node_modules/vue-loader/lib/index.js??vue-loader-options!/app/src/components/content/ShelfDisplayPuzzle.vue?vue&type=script&lang=js&","dependencies":[{"path":"/app/src/components/content/ShelfDisplayPuzzle.vue","mtime":1683275992553},{"path":"/app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/app/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/app/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCgppbXBvcnQgY2xvbmUgZnJvbSAnbG9kYXNoL2Nsb25lJzsKaW1wb3J0IGdldCBmcm9tICdsb2Rhc2gvZ2V0JzsKaW1wb3J0IHNvcnRCeSBmcm9tICdsb2Rhc2gvc29ydEJ5JzsKaW1wb3J0IHsgU3dhcHBhYmxlIH0gZnJvbSAnQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9lczUvZHJhZ2dhYmxlLmJ1bmRsZS5sZWdhY3knOwoKZXhwb3J0IGRlZmF1bHQgewogIHByb3BzOiB7CiAgICBzaGVsZl9kaXNwbGF5X3B1enpsZTogewogICAgICB0eXBlOiBPYmplY3QsCiAgICAgIHJlcXVpcmVkOiB0cnVlLAogICAgfSwKICB9LAoKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgaW1hZ2U6ICcnLAogICAgICBvcmlnaW5hbEltYWdlV2lkdGg6IDAsCiAgICAgIG9yaWdpbmFsSW1hZ2VIZWlnaHQ6IDAsCiAgICAgIHB1enpsZTogW10sCiAgICAgIHB1enpsZVdpZHRoOiAwLAogICAgICBjdXJyZW50U3dhcDogewogICAgICAgIHNvdXJjZUlkOiBudWxsLAogICAgICAgIHRhcmdldElkOiBudWxsLAogICAgICB9LAogICAgICBpc0ZpbmlzaGVkOiBmYWxzZSwKICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIGFzIHRoZSBrZXkgZm9yIGVhY2ggcHV6emxlIHBpZWNlIGl0ZW0KICAgICAgLy8gYW5kIGlzIGJlaW5nIGNvdW50ZWQgdXAgZXZlcnkgdGltZSB0aGUgRE9NIGhhcyBiZWVuIG1hbmlwdWxhdGVkIGJ5IHRoZSBTd2FwcGFibGUKICAgICAgLy8gbGlicmFyeS4gVGhpcyBjYXVzZXMgdnVlIHRvIHJlLXJlbmRlciBhbGwgdGhlIGxpc3QgaXRlbXMgdG8gcmVmbGVjdCB0aGUgY3VycmVudAogICAgICAvLyBkYXRhIHN0YXRlIGNvcnJlY3RseS4KICAgICAgY29tcG9uZW50S2V5OiAwLAogICAgfTsKICB9LAoKICBjb21wdXRlZDogewogICAgcm93cygpIHsKICAgICAgY29uc3Qgcm93cyA9IGdldCh0aGlzLnNoZWxmX2Rpc3BsYXlfcHV6emxlLCAnc2l6ZS5yb3dzJykgfHwgNDsKCiAgICAgIHJldHVybiBwYXJzZUludChyb3dzLCAxMCk7CiAgICB9LAoKICAgIGNvbHVtbnMoKSB7CiAgICAgIGNvbnN0IGNvbHVtbnMgPSBnZXQodGhpcy5zaGVsZl9kaXNwbGF5X3B1enpsZSwgJ3NpemUuY29sdW1ucycpIHx8IDQ7CgogICAgICByZXR1cm4gcGFyc2VJbnQoY29sdW1ucywgMTApOwogICAgfSwKCiAgICBjb2x1bW5XaWR0aCgpIHsKICAgICAgcmV0dXJuIDEwMCAvIHRoaXMuY29sdW1uczsKICAgIH0sCgogICAgY29sdW1uSGVpZ2h0KCkgewogICAgICByZXR1cm4gMTAwIC8gdGhpcy5yb3dzOwogICAgfSwKCiAgICBwdXp6bGVIZWlnaHQoKSB7CiAgICAgIGNvbnN0IGhlaWdodFJhdGlvID0gdGhpcy5wdXp6bGVXaWR0aCAvIHRoaXMub3JpZ2luYWxJbWFnZVdpZHRoOwoKICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxJbWFnZUhlaWdodCAqIGhlaWdodFJhdGlvOwogICAgfSwKCiAgICBzb3J0ZWRQdXp6bGUoKSB7CiAgICAgIHJldHVybiBzb3J0QnkodGhpcy5wdXp6bGUsICdpbmRleCcpOwogICAgfSwKCiAgICBoYXNTdWNjZXNzTWVzc2FnZSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc3VjY2Vzc01lc3NhZ2UgJiYgdGhpcy5zdWNjZXNzTWVzc2FnZS5sZW5ndGggPiAwOwogICAgfSwKCiAgICBzdWNjZXNzTWVzc2FnZSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc2hlbGZfZGlzcGxheV9wdXp6bGUuc3VjY2Vzc19tZXNzYWdlOwogICAgfSwKICB9LAoKICB3YXRjaDogewogICAgc2hlbGZfZGlzcGxheV9wdXp6bGU6IHsKICAgICAgaW1tZWRpYXRlOiB0cnVlLAogICAgICBkZWVwOiB0cnVlLAogICAgICBoYW5kbGVyKHNoZWxmRGlzcGxheVB1enpsZSkgewogICAgICAgIGNvbnN0IGltYWdlID0gZ2V0KHNoZWxmRGlzcGxheVB1enpsZSwgJ2ltYWdlLnNpemVzLnBvc3QtdGh1bWJuYWlsJyk7CgogICAgICAgIGlmIChpbWFnZSAmJiBpbWFnZS5sZW5ndGggPiAwKSB7CiAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7CiAgICAgICAgfQogICAgICB9LAogICAgfSwKCiAgICBpbWFnZTogewogICAgICBpbW1lZGlhdGU6IHRydWUsCiAgICAgIGhhbmRsZXIoaW1hZ2UpIHsKICAgICAgICBpZiAoIWltYWdlIHx8IGltYWdlLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5pbWFnZUluc3RhbmNlID0gbmV3IEltYWdlKCk7CgogICAgICAgIHRoaXMuaW1hZ2VJbnN0YW5jZS5vbmxvYWQgPSAoKSA9PiB7CiAgICAgICAgICB0aGlzLmdlbmVyYXRlUHV6emxlKCk7CiAgICAgICAgfTsKCiAgICAgICAgdGhpcy5pbWFnZUluc3RhbmNlLnNyYyA9IGltYWdlOwogICAgICB9LAogICAgfSwKICB9LAoKICBtZXRob2RzOiB7CiAgICBnZW5lcmF0ZVB1enpsZSgpIHsKICAgICAgdGhpcy5zdG9yZU9yaWdpbmFsSW1hZ2VEaW1lbnNpb25zKCk7CiAgICAgIHRoaXMuY3JlYXRlUHV6emxlUGllY2VzKCk7CiAgICAgIHRoaXMuc2h1ZmZsZVB1enpsZVBpZWNlcygpOwoKICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgIHRoaXMuY3JlYXRlU3dhcHBhYmxlSW5zdGFuY2UoKTsKICAgICAgfSk7CiAgICB9LAoKICAgIGNyZWF0ZVB1enpsZVBpZWNlcygpIHsKICAgICAgbGV0IGluZGV4ID0gMDsKICAgICAgY29uc3QgcHV6emxlID0gW107CgogICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLnJvd3M7IHJvdyArPSAxKSB7CiAgICAgICAgZm9yIChsZXQgY29sdW1uID0gMDsgY29sdW1uIDwgdGhpcy5jb2x1bW5zOyBjb2x1bW4gKz0gMSkgewogICAgICAgICAgcHV6emxlLnB1c2goewogICAgICAgICAgICBpZDogYCR7cm93fS0ke2NvbHVtbn1gLAogICAgICAgICAgICByb3csCiAgICAgICAgICAgIGNvbHVtbiwKICAgICAgICAgICAgb3JpZ2luYWxJbmRleDogaW5kZXgsCiAgICAgICAgICAgIGluZGV4LAogICAgICAgICAgfSk7CgogICAgICAgICAgaW5kZXggKz0gMTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMucHV6emxlID0gcHV6emxlOwogICAgfSwKCiAgICBzaHVmZmxlUHV6emxlUGllY2VzKCkgewogICAgICBjb25zdCBhdmFpbGFibGVJbmRpY2VzID0gWy4uLkFycmF5KHRoaXMuY29sdW1ucyAqIHRoaXMucm93cykua2V5cygpXTsKCiAgICAgIHRoaXMucHV6emxlID0gdGhpcy5wdXp6bGUubWFwKHBpZWNlID0+IHsKICAgICAgICBjb25zdCBpbmRleCA9IGF2YWlsYWJsZUluZGljZXMKICAgICAgICAgIC5zcGxpY2UoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXZhaWxhYmxlSW5kaWNlcy5sZW5ndGgpLCAxKTsKCiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWRlc3RydWN0dXJpbmcsIG5vLXBhcmFtLXJlYXNzaWduICovCiAgICAgICAgcGllY2UuaW5kZXggPSBpbmRleFswXTsKICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovCgogICAgICAgIHJldHVybiBwaWVjZTsKICAgICAgfSk7CiAgICB9LAoKICAgIGNyZWF0ZVN3YXBwYWJsZUluc3RhbmNlKCkgewogICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLiRyZWZzLnB1enpsZUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucHV6emxlLXBpZWNlcy1jb250YWluZXInKTsKCiAgICAgIHRoaXMuc3dhcHBhYmxlID0gbmV3IFN3YXBwYWJsZShjb250YWluZXIsIHsKICAgICAgICBkcmFnZ2FibGU6ICcucHV6emxlLXBpZWNlJywKICAgICAgfSk7CgogICAgICB0aGlzLnN3YXBwYWJsZS5vbignc3dhcHBhYmxlOnN3YXBwZWQnLCBwYXlsb2FkID0+IHsKICAgICAgICB0aGlzLmN1cnJlbnRTd2FwLnNvdXJjZUlkID0gcGF5bG9hZC5kYXRhLmRyYWdFdmVudC5kYXRhLnNvdXJjZS5kYXRhc2V0LmlkOwogICAgICAgIHRoaXMuY3VycmVudFN3YXAudGFyZ2V0SWQgPSBwYXlsb2FkLmRhdGEuc3dhcHBlZEVsZW1lbnQuZGF0YXNldC5pZDsKICAgICAgfSk7CiAgICAgIHRoaXMuc3dhcHBhYmxlLm9uKCdzd2FwcGFibGU6c3RvcCcsICgpID0+IHsKICAgICAgICBpZiAodGhpcy5pc0N1cnJlbnRTd2FwVmFsaWQoKSkgewogICAgICAgICAgY29uc3Qgc291cmNlUGllY2UgPSB0aGlzLnB1enpsZS5maW5kKHBpZWNlID0+IHBpZWNlLmlkID09PSB0aGlzLmN1cnJlbnRTd2FwLnNvdXJjZUlkKTsKICAgICAgICAgIGNvbnN0IHRhcmdldFBpZWNlID0gdGhpcy5wdXp6bGUuZmluZChwaWVjZSA9PiBwaWVjZS5pZCA9PT0gdGhpcy5jdXJyZW50U3dhcC50YXJnZXRJZCk7CgogICAgICAgICAgY29uc3Qgc291cmNlSW5kZXggPSBjbG9uZShzb3VyY2VQaWVjZS5pbmRleCk7CgogICAgICAgICAgc291cmNlUGllY2UuaW5kZXggPSBjbG9uZSh0YXJnZXRQaWVjZS5pbmRleCk7CiAgICAgICAgICB0YXJnZXRQaWVjZS5pbmRleCA9IHNvdXJjZUluZGV4OwoKICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICAgICAgdGhpcy5jb21wb25lbnRLZXkgKz0gMTsKCiAgICAgICAgICAgIHRoaXMuY2hlY2tXaW5Db25kaXRpb25zKCk7CiAgICAgICAgICB9KTsKICAgICAgICB9CgogICAgICAgIHRoaXMucmVzZXRDdXJyZW50U3dhcCgpOwogICAgICB9KTsKICAgIH0sCgogICAgY2hlY2tXaW5Db25kaXRpb25zKCkgewogICAgICB0aGlzLmlzRmluaXNoZWQgPSB0aGlzLnB1enpsZS5ldmVyeShwaWVjZSA9PiBwaWVjZS5pbmRleCA9PT0gcGllY2Uub3JpZ2luYWxJbmRleCk7CiAgICB9LAoKICAgIGRldGVybWluZVB1enpsZVdpZHRoKCkgewogICAgICB0aGlzLnB1enpsZVdpZHRoID0gdGhpcy4kcmVmcy5wdXp6bGVDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7CiAgICB9LAoKICAgIHN0b3JlT3JpZ2luYWxJbWFnZURpbWVuc2lvbnMoKSB7CiAgICAgIHRoaXMub3JpZ2luYWxJbWFnZVdpZHRoID0gdGhpcy5pbWFnZUluc3RhbmNlLndpZHRoOwogICAgICB0aGlzLm9yaWdpbmFsSW1hZ2VIZWlnaHQgPSB0aGlzLmltYWdlSW5zdGFuY2UuaGVpZ2h0OwogICAgfSwKCiAgICBnZXRQaWVjZURpbWVuc2lvbnMoKSB7CiAgICAgIHJldHVybiB7CiAgICAgICAgd2lkdGg6IHRoaXMucHV6emxlV2lkdGggLyB0aGlzLmNvbHVtbnMsCiAgICAgICAgaGVpZ2h0OiB0aGlzLnB1enpsZUhlaWdodCAvIHRoaXMucm93cywKICAgICAgfTsKICAgIH0sCgogICAgZ2V0UGllY2VYT2Zmc2V0KHBpZWNlKSB7CiAgICAgIGNvbnN0IHBpZWNlV2lkdGggPSB0aGlzLmdldFBpZWNlRGltZW5zaW9ucygpLndpZHRoOwogICAgICBjb25zdCBwaWVjZU9mZnNldCA9IHBpZWNlV2lkdGggKiBwaWVjZS5jb2x1bW4gKiAtMTsKCiAgICAgIHJldHVybiBgJHtwaWVjZU9mZnNldH1weGA7CiAgICB9LAoKICAgIGdldFBpZWNlWU9mZnNldChwaWVjZSkgewogICAgICBjb25zdCBwaWVjZUhlaWdodCA9IHRoaXMuZ2V0UGllY2VEaW1lbnNpb25zKCkuaGVpZ2h0OwogICAgICBjb25zdCBwaWVjZU9mZnNldCA9IHBpZWNlSGVpZ2h0ICogcGllY2Uucm93ICogLTE7CgogICAgICByZXR1cm4gYCR7cGllY2VPZmZzZXR9cHhgOwogICAgfSwKCiAgICBpc0N1cnJlbnRTd2FwVmFsaWQoKSB7CiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTd2FwLnNvdXJjZUlkICE9PSBudWxsICYmIHRoaXMuY3VycmVudFN3YXAudGFyZ2V0SWQgIT09IG51bGw7CiAgICB9LAoKICAgIHJlc2V0Q3VycmVudFN3YXAoKSB7CiAgICAgIHRoaXMuY3VycmVudFN3YXAuc291cmNlSWQgPSBudWxsOwogICAgICB0aGlzLmN1cnJlbnRTd2FwLnRhcmdldElkID0gbnVsbDsKICAgIH0sCgogICAgcmVzdGFydCgpIHsKICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gZmFsc2U7CiAgICAgIHRoaXMuc2h1ZmZsZVB1enpsZVBpZWNlcygpOwogICAgfSwKCiAgICB2aXNpYmlsaXR5Q2hhbmdlZChpc1Zpc2libGUpIHsKICAgICAgaWYgKGlzVmlzaWJsZSkgewogICAgICAgIHRoaXMuZGV0ZXJtaW5lUHV6emxlV2lkdGgoKTsKICAgICAgfQogICAgfSwKICB9LAoKICBtb3VudGVkKCkgewogICAgdGhpcy5kZXRlcm1pbmVQdXp6bGVXaWR0aCgpOwoKICAgIGNvbnN0IG9uUmVzaXplTGlzdGVuZXIgPSAoKSA9PiB7CiAgICAgIHRoaXMuZGV0ZXJtaW5lUHV6emxlV2lkdGgoKTsKICAgIH07CgogICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplTGlzdGVuZXIpOwoKICAgIHRoaXMuJG9uY2UoJ2hvb2s6ZGVzdHJveWVkJywgKCkgPT4gewogICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemVMaXN0ZW5lcik7CiAgICB9KTsKICB9LAp9OwoK"},{"version":3,"sources":["ShelfDisplayPuzzle.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA","file":"ShelfDisplayPuzzle.vue","sourceRoot":"src/components/content","sourcesContent":["<template>\n  <div class=\"puzzle container\">\n    <div ref=\"puzzleContainer\">\n      <h3\n        class=\"text-center\"\n        v-html=\"$options.filters.formatContent(shelf_display_puzzle.headline)\"\n      />\n\n      <h6\n        class=\"mt-4 text-center\"\n        v-html=\"$options.filters.formatContent(shelf_display_puzzle.subheadline)\"\n      />\n\n      <div\n        v-observe-visibility=\"visibilityChanged\"\n        class=\"puzzle-pieces-container mt-16 flex flex-wrap relative focus:outline-none\"\n        :style=\"{\n          width: `${puzzleWidth}px`,\n          height: `${puzzleHeight}px`,\n        }\"\n      >\n        <div\n          v-for=\"piece in sortedPuzzle\"\n          :key=\"`${componentKey}${piece.id}`\"\n          class=\"puzzle-piece relative\"\n          :class=\"{ 'with-outline' : !isFinished}\"\n          :data-id=\"piece.id\"\n          :style=\"{\n            width: `${getPieceDimensions().width}px`,\n            height: `${getPieceDimensions().height}px`,\n            backgroundImage: `url(${image})`,\n            backgroundRepeat: 'no-repeat',\n            backgroundSize: `${puzzleWidth}px ${puzzleHeight}px`,\n            backgroundPosition: `${getPieceXOffset(piece)} ${getPieceYOffset(piece)}`,\n          }\"\n        >\n          <div\n            class=\"puzzle-piece-indicator w-full h-full opacity-50 bg-blue-400\"\n          />\n        </div>\n      </div>\n    </div>\n\n    <div\n      v-if=\"isFinished\"\n      class=\"mt-4\"\n    >\n      <h2\n        v-if=\"hasSuccessMessage\"\n        class=\"mb-4 px-8 text-center\"\n        v-html=\"$options.filters.formatContent(successMessage)\"\n      />\n\n      <div class=\"flex justify-center\">\n        <apo-button\n          class=\"puzzle-restart-button button button--tiny button--outlined\"\n          type=\"button\"\n          @click=\"restart\"\n          v-text=\"$t('modules.shelfDisplay.restart')\"\n        />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\n\nimport clone from 'lodash/clone';\nimport get from 'lodash/get';\nimport sortBy from 'lodash/sortBy';\nimport { Swappable } from '@shopify/draggable/lib/es5/draggable.bundle.legacy';\n\nexport default {\n  props: {\n    shelf_display_puzzle: {\n      type: Object,\n      required: true,\n    },\n  },\n\n  data() {\n    return {\n      image: '',\n      originalImageWidth: 0,\n      originalImageHeight: 0,\n      puzzle: [],\n      puzzleWidth: 0,\n      currentSwap: {\n        sourceId: null,\n        targetId: null,\n      },\n      isFinished: false,\n      // This property is used in conjunction as the key for each puzzle piece item\n      // and is being counted up every time the DOM has been manipulated by the Swappable\n      // library. This causes vue to re-render all the list items to reflect the current\n      // data state correctly.\n      componentKey: 0,\n    };\n  },\n\n  computed: {\n    rows() {\n      const rows = get(this.shelf_display_puzzle, 'size.rows') || 4;\n\n      return parseInt(rows, 10);\n    },\n\n    columns() {\n      const columns = get(this.shelf_display_puzzle, 'size.columns') || 4;\n\n      return parseInt(columns, 10);\n    },\n\n    columnWidth() {\n      return 100 / this.columns;\n    },\n\n    columnHeight() {\n      return 100 / this.rows;\n    },\n\n    puzzleHeight() {\n      const heightRatio = this.puzzleWidth / this.originalImageWidth;\n\n      return this.originalImageHeight * heightRatio;\n    },\n\n    sortedPuzzle() {\n      return sortBy(this.puzzle, 'index');\n    },\n\n    hasSuccessMessage() {\n      return this.successMessage && this.successMessage.length > 0;\n    },\n\n    successMessage() {\n      return this.shelf_display_puzzle.success_message;\n    },\n  },\n\n  watch: {\n    shelf_display_puzzle: {\n      immediate: true,\n      deep: true,\n      handler(shelfDisplayPuzzle) {\n        const image = get(shelfDisplayPuzzle, 'image.sizes.post-thumbnail');\n\n        if (image && image.length > 0) {\n          this.image = image;\n        }\n      },\n    },\n\n    image: {\n      immediate: true,\n      handler(image) {\n        if (!image || image.length === 0) {\n          return;\n        }\n\n        this.imageInstance = new Image();\n\n        this.imageInstance.onload = () => {\n          this.generatePuzzle();\n        };\n\n        this.imageInstance.src = image;\n      },\n    },\n  },\n\n  methods: {\n    generatePuzzle() {\n      this.storeOriginalImageDimensions();\n      this.createPuzzlePieces();\n      this.shufflePuzzlePieces();\n\n      this.$nextTick(() => {\n        this.createSwappableInstance();\n      });\n    },\n\n    createPuzzlePieces() {\n      let index = 0;\n      const puzzle = [];\n\n      for (let row = 0; row < this.rows; row += 1) {\n        for (let column = 0; column < this.columns; column += 1) {\n          puzzle.push({\n            id: `${row}-${column}`,\n            row,\n            column,\n            originalIndex: index,\n            index,\n          });\n\n          index += 1;\n        }\n      }\n\n      this.puzzle = puzzle;\n    },\n\n    shufflePuzzlePieces() {\n      const availableIndices = [...Array(this.columns * this.rows).keys()];\n\n      this.puzzle = this.puzzle.map(piece => {\n        const index = availableIndices\n          .splice(Math.floor(Math.random() * availableIndices.length), 1);\n\n        /* eslint-disable prefer-destructuring, no-param-reassign */\n        piece.index = index[0];\n        /* eslint-enable */\n\n        return piece;\n      });\n    },\n\n    createSwappableInstance() {\n      const container = this.$refs.puzzleContainer.querySelector('.puzzle-pieces-container');\n\n      this.swappable = new Swappable(container, {\n        draggable: '.puzzle-piece',\n      });\n\n      this.swappable.on('swappable:swapped', payload => {\n        this.currentSwap.sourceId = payload.data.dragEvent.data.source.dataset.id;\n        this.currentSwap.targetId = payload.data.swappedElement.dataset.id;\n      });\n      this.swappable.on('swappable:stop', () => {\n        if (this.isCurrentSwapValid()) {\n          const sourcePiece = this.puzzle.find(piece => piece.id === this.currentSwap.sourceId);\n          const targetPiece = this.puzzle.find(piece => piece.id === this.currentSwap.targetId);\n\n          const sourceIndex = clone(sourcePiece.index);\n\n          sourcePiece.index = clone(targetPiece.index);\n          targetPiece.index = sourceIndex;\n\n          this.$nextTick(() => {\n            this.componentKey += 1;\n\n            this.checkWinConditions();\n          });\n        }\n\n        this.resetCurrentSwap();\n      });\n    },\n\n    checkWinConditions() {\n      this.isFinished = this.puzzle.every(piece => piece.index === piece.originalIndex);\n    },\n\n    determinePuzzleWidth() {\n      this.puzzleWidth = this.$refs.puzzleContainer.getBoundingClientRect().width;\n    },\n\n    storeOriginalImageDimensions() {\n      this.originalImageWidth = this.imageInstance.width;\n      this.originalImageHeight = this.imageInstance.height;\n    },\n\n    getPieceDimensions() {\n      return {\n        width: this.puzzleWidth / this.columns,\n        height: this.puzzleHeight / this.rows,\n      };\n    },\n\n    getPieceXOffset(piece) {\n      const pieceWidth = this.getPieceDimensions().width;\n      const pieceOffset = pieceWidth * piece.column * -1;\n\n      return `${pieceOffset}px`;\n    },\n\n    getPieceYOffset(piece) {\n      const pieceHeight = this.getPieceDimensions().height;\n      const pieceOffset = pieceHeight * piece.row * -1;\n\n      return `${pieceOffset}px`;\n    },\n\n    isCurrentSwapValid() {\n      return this.currentSwap.sourceId !== null && this.currentSwap.targetId !== null;\n    },\n\n    resetCurrentSwap() {\n      this.currentSwap.sourceId = null;\n      this.currentSwap.targetId = null;\n    },\n\n    restart() {\n      this.isFinished = false;\n      this.shufflePuzzlePieces();\n    },\n\n    visibilityChanged(isVisible) {\n      if (isVisible) {\n        this.determinePuzzleWidth();\n      }\n    },\n  },\n\n  mounted() {\n    this.determinePuzzleWidth();\n\n    const onResizeListener = () => {\n      this.determinePuzzleWidth();\n    };\n\n    window.addEventListener('resize', onResizeListener);\n\n    this.$once('hook:destroyed', () => {\n      window.removeEventListener('resize', onResizeListener);\n    });\n  },\n};\n\n</script>\n\n<style lang=\"scss\" scoped>\n\n.puzzle {\n  &-piece {\n\n    &.with-outline {\n      outline: 2px solid #0099FF;\n    }\n\n    &-indicator {\n      @apply opacity-0;\n\n      transition: opacity 0.1s ease;\n    }\n\n    &.draggable-source--is-dragging &-indicator {\n      @apply opacity-75;\n    }\n  }\n\n  &-win-overlay {\n    @apply absolute;\n    @apply left-0;\n    @apply top-0;\n    @apply w-full;\n    @apply h-full;\n    @apply bg-blue-500;\n    @apply z-10;\n    @apply opacity-50;\n\n    animation-name: flash;\n    animation-duration: 1s;\n    animation-timing-function: ease;\n  }\n\n  &-restart-button {\n    @apply p-0;\n    @apply text-gray-900;\n    @apply underline;\n    @apply text-3xl;\n    @apply font-normal;\n  }\n\n  /deep/ .draggable-mirror {\n    @apply opacity-75;\n  }\n}\n\n@keyframes flash {\n  0%,\n  25%,\n  75% {\n    @apply opacity-0;\n  }\n\n  50%,\n  100% {\n    @apply opacity-50;\n  }\n}\n\n</style>\n"]}]}